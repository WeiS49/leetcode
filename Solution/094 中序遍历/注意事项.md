
# 中序遍历

## 题目

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

## 示例

示例 1:
输入：root = [1,null,2,3]
输出：[1,3,2]

示例 2：
输入：root = []
输出：[]

示例 3：
输入：root = [1]
输出：[1]

示例 4：
输入：root = [1,2]
输出：[2,1]

## 解法一 递归

直接使用递归进行求解, 递归的特性就隐含了栈, 所以相当于是后台自动创建栈并维护.

栈不为空的条件为 '总是有节点用于遍历', 所以可以写作
```
if root 
```

## 解法二 迭代(模拟递归)

这种解法通过手动创建一个栈用来保存待处理的数据, 同时利用了栈的特性 —— **先进后出**, 以此来放入更多节点.

同时因为栈的特性, 在向栈中放入节点时应该使用**相反的顺序**

栈不为空即手动创建的栈不为空
```
while stack
```

### 为什么使用flag

因为深度优先遍历必然要向栈中添加很多新的数据, 为了防止这些新数据添加重复, 所以引入flag对其操作进行判断

## 注意

这是一道 深度优先遍历(DTS) 的题目, 用 **栈** 实现.

因为栈的特性是先进先后出, 由于每次都是最后一个数据出栈, 所以可以利用这个特性优先对新数据进行操作, 适合待处理数据的扩展 —— 深度优先遍历

同时由于是二叉树相关题目, 所以使用递归解法.

递归的进行条件是 '当栈不为空'

中序遍历的顺序是: 左->中->右

### 特殊情况处理

如果输入值root为空 直接结束程序(应对特殊情况)
if not root: return []
