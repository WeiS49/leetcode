

# 环形链表

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

## 题目

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]

## 解法1 辅助空间

### 思路

* 使用额外空间保存节点**地址**, 判断有无重复

两种实现:
1. 使用哈希表(字典)存储节点的**地址**和**出现次数**
2. 使用集合保存节点**地址**

* 该方法运行效率很差

## 解法1.1 递归

### 思路

* 每遍历一个节点, 都修改其.val值, 判断值是否修改过即可找出是否有环

## 解法2 双指针

### 思路

* 类似龟兔赛跑, 一快一慢的两个指针, 在重复的跑道上总会相遇

两种实现:
1. 设置while循环终止条件(某一指针到达终点)
2. 使用try except规避掉上面的问题, 出现不符合需求的条件(到达终点)直接执行except代码段

* 运行效率好于方法1, 第二种实现更好

while slow != None
不需要写, 因为slow不可能为空, 写这个的目的只为了规避空链表的情况, 但这点已经在最开始解决了. 相反, 如果只写这一句而不写最开始的条件, 会因为"None type has no attribute 'next'" 而报错.

