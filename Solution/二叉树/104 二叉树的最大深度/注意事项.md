
# 二叉树的最大深度

## 题目

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

## 示例

给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

## 解法1

如果根节点存在

则同时对左右子节点调用递归函数, 并对结果+1(根节点)

## 注意



* 这一个**罐头写法**, 也就是说是某种情况下的标准写法, 除了**操作语句**因题而异

  * **操作语句**的功能是控制**中间值**

  * LC543. 二叉树的直径

    * 中间值用来保存当前最大直径
    * 操作语句用来将中间值和当前直径做比较

  * 查找当前最大节点数

    * 每当遍历一个节点, 就对中间值 "+1"
    * 最终结果就是返回当前树中的所有节点

    ![](https://raw.githubusercontent.com/WeiS49/Bilder/main/img/leetcode/part/104_allNode.png)

* 思路

  * 使用**中间值**保存最终的结果

  * depth函数

    * 退出条件 —— 没有节点的情况返回0

    * 获取左右节点

    * **操作语句**

    * 返回最大长度

      ```
      return max(l, r) + 1 # +1即为当前节点
      ```

      

      





关于二叉树的题目, 使用 **递归**

也就是说, 只要每次if语句(该节点有值)成立, 返回值就为1

每次递归的返回值都可以写成max(左节点的值, 右节点的值) + 1, 

(除root节点外))节点else语句成立的前提是父节点的if语句成立, 所以不论如何父节点都会+1

else语句成立的情况是两个子节点都为null
即max(0, 0) + 1, 结果即为1



* 使用栈模拟递归
  * 特殊情况处理: if not root: return 0
  * 初始值添加root
  * 循环
    * 清空当前层的内容
      * 添加下一层的元素
    * 层数 + 1
  * 返回层数







