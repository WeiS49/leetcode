
# 删除链表中的倒数第N个节点

## 前言

* 一般链表题目的解法都会先定义一个**前置节点**, 指向链表的头节点
> result.Next = head

* 定义一个**指向目标元素**(待删除节点)的指针pre, 默认置为空
> pre = nil

## 题目

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

输入：head = [1], n = 1
输出：[]

输入：head = [1,2], n = 1
输出：[1]


## 方法1 快慢指针

### 介绍

* 问题: 如何获得一段跑道的中间位置?
* 解法: 假设有两个人A和B, A的速度是B的两倍, 则二人同时起跑, 当A到达终点的时候, B所在的位置正好是跑道的正中间. 

* 在链表的题目中, 可以设计两个指针, 其移动速度不同但遵循一定的规律, 当快的指针到达终点的时候, 慢指针正好到达目标位置, 从而进行求解.

### 题解

* 设置快慢指针x、y, 当x到达终点时, y应该正好在倒数第 n 的位置上, 则x应该领先y, n个节点. 但如果想方便对被删除节点z进行操作, 则y应该指向倒数第 n - 1 的位置, 则x应该领先y, n + 1的位置.
* 关键在于**快指针的终止条件**(肯定是要遍历整个链表, 但何时停止)和**慢指针的移动条件**(二者的距离)

Node = listNode(0)
Node.next = head
slow = Node
fast = Node.next
count = 0
while fast:
    if count >= n:
        slow = slow.next
    count += 1
    fast = fast.next
return Node.next




### 注意

1. 快慢指针的距离
   * 若快指针的while限定条件是'不为空'(while fast), 则fast的初始值应该为Node.next
   * 反之, 快指针的下一位'不为空'(while fast.next != None), fast = Node即可

2. count的作用
   * count的大小决定了慢指针何时移动, 因为n的值一定, 且条件为(count >= n), 所以count越大, 慢指针越早移动; 
   * 所以这就涉及到了 **+ 1** 的处理方式, 究竟是通过slow和fast的值不一来解决, 还是通过修改count初始值来进行处理, 我觉得前者更好一些 —— 这相当于规避了问题, 而不是修修补补.



## 问题

* 'NoneType' object has no attribute 'next'?
* 在这题中, 可能是链表越界


