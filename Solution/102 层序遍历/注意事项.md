
# 层序遍历

## 题目

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）

## 示例

二叉树：[3,9,20,null,null,15,7],


⁠   3
⁠  / \
⁠ 9  20
⁠   /  \
⁠  15   7


返回其层序遍历结果：


[
⁠ [3],
⁠ [9,20],
⁠ [15,7]
]

## 解法一 迭代

声明列表 res 用于保存每一层的值

声明一个列表 queue 用作队列, 保存每一层的节点

当queue不为空时, 循环继续

声明一个列表level用于保存每一层的值, 既然是一层的值, 那就肯能不只有一个, 所以就要 **遍历** 每一层的值, 所以需要每一层的长度 len(queue)

从queue中分别取出每一个节点进行操作: 
1. 将值添加到level中
2. 如果有左节点, 左节点添加到queue中
3. 如果有右节点, 右节点添加到queue中

### 和DFS相比, 为什么不用flag

广度优先遍历使用循环添加值, 并且先进先出(队列), 所以不涉及这个问题(直接规避掉了)

## 注意

因为是层序遍历, 所以属于 广度优先遍历(BFS) 的题目, 广度优先遍历使用 **队列** 实现

队列的特性是先进先出, 不会根据后输入数据而改变原有顺序(就是排队), 适合一层一层的遍历 —— 广度优先遍历

是二叉树的题目, 使用 **递归** 解法

递归的条件: **队列不为空**

关键在于想好栈和队列的关系, 
对于深度优先遍历使用栈确保对后续数据进行优先操作
对于广度优先遍历使用队列确保每层数据的处理优先级不会被后续数据影响

### 特殊情况处理

如果输入值root为空 直接结束程序(应对特殊情况)
if not root: return []

