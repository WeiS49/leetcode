## 题干

* 题目的描述及输入输出案例(图片?)



## 相似

* 和以前做过的题有什么相似之处

  ```
  相似代码
  ```

  

## 心得

* 这就相当于一个二维的爬楼梯
  * 由此可见, 题目从 easy -> middle 的一种套路就是将一维的问题转变成二维

* 回忆一下爬楼梯

  ```
  # 假设一次只能爬1级楼梯
  # 则第n级楼梯的爬法 == 全部能够一步到达的爬法之和
  s(1) == s(2) == s(3) == ... == s(n)
  
  # 爬楼梯可以选择爬1级或2级
  s(3) == s(2) + s(1) # 爬到第3级楼梯的爬法 == 第2级楼梯 + 第1级楼梯
  # 因为第3级楼梯可以从第2级或第1级楼梯一步到达, 第一级楼梯
  
  
  推论: 
  s(5) == s(4) + s(3)
  ...
  s(n) == s(n-1) + s(n-2) # 动态规划的递推式
  ```

* 在本题中

  * 可以向左、向下两个进行爬楼梯, 最终目的地是"楼梯顶端"

  * 相当于一次走1级、2级楼梯变成了向左走1级、向右走1级

    ```
    # n表示此时位置
    s(n) == s(左) + s(右)  
    ```

  * 因为涉及两个方向, 相当于二维空间

    ```
    # [i-1]、[j-1]分别代表左、右两个位置, 即到达的可能性
    s[i][j] = s[i - 1] + s[j - 1]
    ```

* 有了递推式, 关键就在于赋初值

  * 也就是动态规划中标准的

    ```
    dp = [1] * n # 这是一维的情况
    ```

  * 在二维空间中, 就是对x=0, y=0的所有结果赋初值1

    ```
    dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]
    # 因为在python中, 列表的创建是逐行进行的
    # 所以要创建一个m行n列的数组, 需要用range(m)次循环创建二位列表(的行), 而列为n次
    # 同时要考虑赋初值的情况
    	# 第一行手动创建(值为1), 此时只需循环range(m-1)次
    	# 每一列的第一个值都为1, 则对于其他列来讲, 只需创建n-1个[0]即可
    ```

* 创建完列表, 接下来是循环的问题

  * 由于第一行、第一列都已经有值, 则循环时不需要考虑

    ```
    for i in range(1, m):
    	for j in range(1, n):
    		s[i][j] = s[i-1][j] + s[i][j-1]
    
    # 也可以颠倒顺序, 不过更推荐前者, 更符合思考习惯
    
    for j in range(1, n):
    	for i in range(1, m):
    		s[i][j] = s[i-1][j] + s[i][j-1]
    ```

    

## 参考资料

[有价值的参考信息](https://leetcode-cn.com/)