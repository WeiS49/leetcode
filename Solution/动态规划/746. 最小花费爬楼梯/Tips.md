## 题干

* 题目的描述及输入输出案例(图片?)



## 相似

* 第70题 —— 爬楼梯

  * 只有核心的操作代码不同, 初始化和返回操作完全一致
  * 这也说明了对于动态规划题目来讲, 很多时候真正的差异就在于核心代码, 而核心代码也是由同样的初始值dp(list)得到的, 所以关键在于怎么根据题意对dp和给定数据的操作.
  
  
  
  

## 心得

* 一般来讲像这样的题都有另外的一种做法 —— 不用数组保存中间值, 直接使用几个变量保存计算的中间值, 这样可以让Space -> O(1)

* 为什么遍历的范围是range(2, length + 1)?

  * 在这种动态规划的题目中, 为了方便操作(操作两个数, 第三个数用来赋值), 所以采用了索引为

    i - 2, i - 1, i用来完成操作, 如果不是这样, 就需要单独考虑索引的位置, 让解题变得复杂; 在这种情况下, 当遍历范围右区间为"< length + 1"时, 刚好能够覆盖所有情况, 所以这样写.

* 核心思路

  * 这种题最关键的就是找到**动态规划方程**, 剩余的都是罐头(或者说多数都是)

  

  * 解法1

  * dp的目的: 到达第i格的最小cost

    * 由题意可知, 从起点出发cost为0, 可以走1、2步, 所以dp[0] = dp[1] = 0

  * 在这道题中, 动态规划方程的思路是:

    * **离开时**计算消耗 —— 反向

    * 使用dp(list)代表第i点的最小路径

    * 从第i点出发, 需要的消耗要添加第i点的cost —— dp[i] + cost[i]

    * 一次能走1、2格, 也就是说能从第i-1或第i-2格出发

      ```
      dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]
      ```

    * 答案要求找到最小路径, dp[i]即为min(一个台阶的消耗, 两个台阶的消耗)

      ```
      dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
      ```

    * 到达这一步的消耗, 是从上一步出发还是从上上步出发?(寻求最优解)

  

  * 解法2

  * 思路:

    * **到达时**计算消耗 —— 把每一级台阶作为起点(正向)
    * 我到达第i级, 是从i-1或i-2上来的, 所以第i级的消耗为当级cost + 上两级中的最小值

    ```
    dp[0], dp[1] = cost[0], cost[1]
    ```

    * 这种赋值方式更容易理解

  * dp的目的: 

    ```
    cost[i] + min(dp[i-1], dp[i-2])
    ```

    * 如果我走这一步, 是从上一步出发好还是从上上步出发好?(走完每一步)

    ```
    return min(dp[-1], dp[-2]) # 因为是遍历每种可能性, 所以要对最后两步作比较
    ```

    



* 套路

  1. 明确dp的目的, 上面的两种写法dp的目的不同, 所以公式也有所区别

  2. 明确目的后, 根据前3位(dp[0]、dp[1]、dp[2])找到dp公式的规律
  3. 写出dp公式(或者在交流后), 完成求解

## 参考资料

[官方题解](https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/)

[另一种思路](https://leetcode.com/problems/min-cost-climbing-stairs/discuss/657490/Python-solution-from-a-beginner-(some-easy-steps-to-follow-to-solve-dp))

